# Sootup-Paths-Analysis
使用sootup工具解析java方法，拆解路径并筛选关键路径

# SootUp 项目结构

## 目录结构

```
SootUp/
├── README.md                    # 项目说明文档
├── pom.xml                      # Maven配置文件
├── SootUpAnalyzer.java          # 核心分析器类
├── sootup_integration.py        # Python集成脚本
├── TestClass.java               # 测试用Java类
├── build.sh                     # Linux/Mac构建脚本
├── build.bat                    # Windows构建脚本
├── USAGE_GUIDE.md               # 详细使用指南
├── PROJECT_STRUCTURE.md         # 项目结构说明
└── target/                      # Maven构建输出目录
    └── sootup-analyzer-1.0.0.jar
```

## 文件说明

### 核心文件

1. **SootUpAnalyzer.java**
   - 主要的Java分析器类
   - 提供类分析、方法分析、调用图分析功能
   - 支持JSON格式输出

2. **sootup_integration.py**
   - Python集成脚本
   - 用于在AliPathMaker项目中调用SootUp
   - 提供文件编译和分析功能

3. **pom.xml**
   - Maven项目配置文件
   - 包含SootUp相关依赖
   - 配置构建和打包选项

### 测试文件

1. **TestClass.java**
   - 用于测试SootUp分析功能的示例Java类
   - 包含多种方法调用和语句类型

## 依赖关系

### Maven依赖
- sootup.core (2.0.0)
- sootup.java.bytecode.frontend (2.0.0)
- sootup.java.core (2.0.0)
- sootup.callgraph (2.0.0)
- sootup.analysis.intraprocedural (2.0.0)
- jackson-databind (2.15.2)
- slf4j-simple (2.0.7)

### 系统要求
- Java 11+
- Maven 3.6+
- Python 3.8+ (用于集成脚本)

大家重点关注一下CFGGeneration中的AllCFGToCSV方法，我们的关键路径筛选要加入到这个方法中。
简单解释一下这个AllCFGToCSV方法：
这个方法是为了将我们找到的CFG路径/依赖信息等写入一个csv文件（表格文件），我们要在它写入之前删掉不关键的路径，保留关键路径。
重点关注的两个数据结构：
private ArrayList<ArrayList<Integer>> routeList;
private transient Map<Integer,Stmt> Line2StmtMap;

第一个数据结构元素为数组的数组，sootup会给每个jimlple语句进行编号（这个大家应该懂，因为你们用过sootup，如果不懂的话再查一下），那么想记录目标方法的多条路径，只需要记录多个数组即可，例如：路径1是【1，3，6，8】，路径2是【1，2，4，6】，路径3是【2，5，6，7】等等，routelist就是用来记录这个的。

第二个数据结构是记录上述编号和stmt语句的对应关系，是一个map（int和stmt的映射关系），因为编号和stmt语句是一对一关系，具体使用看AllCFGToCSV中看csv写入时候是怎么用的就行。

大家的任务：
利用这两个数据结构，进行关键路径筛选，Line2StmtMap 中的值类型是sootup支持的Stmt类型，很多sootup相关方法可以对其使用。具体而言，我们需要先获得路径数目，然后设置一个默认值（比如40%，意味着最终筛选出的关键路径是原路径总数的40%），然后对每条路径计算加权评分，最终得到关键路径，将关键路径写入，非关键路径不写入。有问题随时联系！








筛选关键路径原理
1. 核心思想
在复杂的软件代码中，并非所有执行路径都具有同等的重要性。某些路径由于其
执行逻辑、对核心数据的操作或结构上的特点，更容易包含潜在的安全漏洞或关
键业务逻辑。本方法旨在通过一套量化的评分模型，从海量的代码执行路径中自
动识别和筛选出最值得进行安全审计和分析的“关键路径”，从而显著提升代码审计
的效率和准确性。
其核心思想是：一条路径的重要性（或风险性）与其长度、逻辑复杂度和对关键
变量的操作频率正相关。 通过为这几个维度建立评分模型，可以计算出每条路径
的综合得分，并以此为依据进行排序。
2. 路径评分模型
我们通过以下三个核心指标来综合评估每条路径的“关键性”：
2.1. 路径长度分 (Path Length Score)
此分数衡量路径的执行深度。一条过长的路径可能意味着更复杂的业务逻辑，或
者存在潜在的循环或递归问题，从而增加了分析的难度和出错的可能性。
计算方法: 直接读取分析工具（如 comex）生成的路径数据中的
path_length
 字段的值。该值通常代表了路径所经过的代码基本块或语句的
数量。
备用方法: 也可以通过计算路径节点数组（如 
paths
 数组）中的元素总
数来得到相同的结果。
2.2. 逻辑复杂度分 (Branching Score)
此分数用于衡量路径穿越了多少个决策点（如条件判断或循环）。高逻辑复杂度
的路径意味着该路径的执行依赖于多重条件的成立，这些复杂的条件组合往往是
逻辑漏洞的高发区。
计算方法:
 1. 遍历指定路径中的每一个节点。
2. 根据节点信息，在抽象语法树 (AST) 或节点属性库中查找对应节点的类型
(
 t
 ype_label 
)。
3. 统计路径中节点类型为条件语句（如 
if
、
switch 
）或循环语句（如
for 
、
while 
）的节点总数。这个总数即为逻辑复杂度分。
2.3. 关键变量操作分 (Key Variable Score)
此分数衡量路径是否对程序的核心数据进行了创建或修改操作。对关键数据（如
用户输入、认证凭据、返回结果）的修改是安全审计中需要重点关注的行为，因
为不当的操作可能直接导致漏洞。
计算方法:
 1. 定义关键变量: 首先，需要定义一个“关键变量”列表。这些变量通常包括：
方法的参数（尤其是代表外部输入的参数，如 
员变量，以及最终会被 
request
 对象）、类的成
return
 语句返回的变量。
2. 遍历与识别: 遍历路径中的每一个节点，并解析其对应的代码语句。
3. 匹配与计分: 通过字符串匹配或结合AST分析（查找 
Assignment
 节
点），识别出代码语句中是否存在对“关键变量”的写操作（如赋值 =
）。
4. 累加计分: 每当发现一次对关键变量的写操作，就进行计数。路径中对关
键变量写操作的总次数，即为该路径的关键变量操作分。
3. 执行流程
为了实现上述评分模型，需要一个系统化的执行流程：
第一阶段：预处理 (Preprocessing)
 1. 加载代码结构: 加载项目的抽象语法树 (AST) 的JSON文件，用于后续的节点
类型和代码分析。
2. 生成关键变量列表: （核心步骤）通过分析AST，自动生成一个初始的“关键变
量”列表。这可以通过查找 
MethodDeclaration
 节点来识别方法参数，并通过
分析 
ReturnStatement
 节点来识别方法最终返回的变量。此列表也可以由审
计人员进行人工补充和确认。
第二阶段：路径评分 (Path Scoring)
 1. 遍历路径: 逐一处理由路径分析工具（如 comex）生成的所有路径文件。
2. 计算各项得分: 对于每一条路径，按照上文定义的模型分别计算其 路径长度
分、逻辑复杂度分 和 关键变量操作分。
score_length 
: 直接从路径文件中获取。
score_branch 
: 遍历路径节点，查询节点类型并计数。
score_vars 
: 遍历路径节点，解析其在AST中的对应子树，检查是否存在
对“关键变量”列表中的变量进行赋值的 
Assignment
 节点，并进行计数。
3. 计算总分: 将上述各项得分通过加权求和的方式，计算出每条路径的最终综合
得分。
Total_Score = (w1 * score_length) + (w2 * score_branch) + (w3
 * score_vars)
其中 
w1
 , 
w2
 , 
w3
 是各项分数的权重，可根据实际审计需求进行调整。
第三阶段：排序与呈现 (Ranking & Presentation)
 1. 全局排序: 对所有已计算出总分的路径，进行降序排序。
2. 结果呈现: 将得分最高的路径作为“关键路径”优先呈现给审计人员。呈现的信
息应清晰明了，包括路径的综合得分、各分项得分，并能关联回源代码的具体
行号，方便审计人员直接进行深入分析和代码审查

